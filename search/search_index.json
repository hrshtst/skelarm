{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"skelarm","text":"<p>A lightweight, physics-based dynamics simulator for a configurable planar robot arm. <code>skelarm</code> focuses on kinematics and dynamics simulation without collision detection or complex shape rendering, treating the robot as a \"skeleton\" of links.</p>"},{"location":"#features","title":"Features","text":"<ul> <li>Configurable Robot: Define arbitrary planar robots with custom link lengths, masses, inertias, and centers of mass. Support for TOML configuration files.</li> <li>Kinematics:<ul> <li>Forward Kinematics (FK) to compute end-effector position from joint displacements.</li> </ul> </li> <li>Dynamics (Planar, No Gravity):<ul> <li>Inverse Dynamics (ID) using Recursive Newton-Euler algorithm.</li> <li>Forward Dynamics (FD) using mass matrix and Coriolis/centrifugal terms.</li> <li>Physics integration using <code>scipy.integrate.solve_ivp</code>.</li> <li>Note: Gravity is explicitly ignored as the robot operates on a horizontal plane.</li> </ul> </li> <li>Visualization:<ul> <li>Static plotting with <code>matplotlib</code>.</li> <li>Interactive GUI visualizer with <code>PyQt6</code> and joint sliders.</li> </ul> </li> <li>Quality Assurance: Fully typed, tested with <code>pytest</code> and <code>hypothesis</code>, and linted with <code>ruff</code>.</li> </ul>"},{"location":"#getting-started","title":"Getting Started","text":""},{"location":"#prerequisites","title":"Prerequisites","text":"<ul> <li>Python 3.12 or higher.</li> <li><code>uv</code> package manager (recommended) or standard <code>pip</code>.</li> </ul>"},{"location":"#installation","title":"Installation","text":"<ol> <li> <p>Clone the repository: <pre><code>git clone https://github.com/hrshtst/skelarm.git\ncd skelarm\n</code></pre></p> </li> <li> <p>Install dependencies using <code>uv</code> (Recommended): <pre><code>uv sync\n</code></pre>     Or using <code>make</code>:     <pre><code>make install\n</code></pre></p> <p>Alternatively, using pip: <pre><code>pip install .\n</code></pre></p> </li> </ol>"},{"location":"#usage-examples","title":"Usage Examples","text":""},{"location":"#toml-configuration","title":"TOML Configuration","text":"<p>You can define robot configurations in TOML files. See <code>examples/simple_robot.toml</code> or <code>examples/four_dof_robot.toml</code>.</p> <pre><code>[[link]]\nlength = 1.0\nmass = 2.0\ninertia = 0.5\ncom = [0.5, 0.0]        # Center of mass [x, y] relative to joint\nlimits = [-180.0, 180.0]  # Joint limits [min, max] in degrees\n\n[[link]]\nlength = 0.8\n# ...\n</code></pre> <p>Load it using <code>Skeleton.from_toml</code>:</p> <pre><code>from skelarm import Skeleton\nskeleton = Skeleton.from_toml(\"path/to/robot.toml\")\n</code></pre>"},{"location":"#4-dof-simulation-example","title":"4-DOF Simulation Example","text":"<p>Run a dynamic simulation of a 4-DOF robot loaded from a TOML file:</p> <pre><code>uv run python examples/simulate_four_dof.py\n</code></pre>"},{"location":"#interactive-visualizer","title":"Interactive Visualizer","text":"<p>Launch the PyQt6 GUI to manipulate a 3-link robot arm with sliders:</p> <pre><code>uv run python examples/interactive_gui.py\n</code></pre>"},{"location":"#basic-kinematics-plotting","title":"Basic Kinematics &amp; Plotting","text":"<p>Run a script that defines a robot, computes its kinematics, and plots it using Matplotlib:</p> <pre><code>uv run python examples/basic_plotting.py\n</code></pre>"},{"location":"#dynamics-simulation","title":"Dynamics Simulation","text":"<p>You can use the library to simulate robot motion. See <code>src/skelarm/dynamics.py</code> and <code>tests/test_dynamics.py</code> for API usage.</p> <pre><code>from skelarm import LinkProp, Skeleton, simulate_robot\nimport numpy as np\n\n# Define a single link\nlink = LinkProp(length=1.0, m=1.0, i=0.1, rgx=0.5, rgy=0.0, qmin=-np.pi, qmax=np.pi)\nskeleton = Skeleton([link])\n\n# Initial state\nskeleton.q = np.array([0.0])\nskeleton.dq = np.array([0.0])\n\n# Simulation parameters\ntime_span = (0.0, 1.0)\ndef control_torques(t, skel):\n    return np.array([0.0]) # Zero torque\n\n# Run simulation\ntimes, q_traj, dq_traj = simulate_robot(skeleton, time_span, control_torques)\n</code></pre>"},{"location":"#running-tests","title":"Running Tests","text":"<p>This project uses <code>pytest</code> for unit testing and <code>hypothesis</code> for property-based testing of physics consistency.</p> <p>To run the full test suite:</p> <pre><code>make test\n# OR\nuv run pytest\n</code></pre> <p>To run tests with coverage report:</p> <pre><code>make test-cov\n</code></pre>"},{"location":"#development","title":"Development","text":"<p>We use <code>ruff</code> for linting and formatting, and <code>pyright</code> for static type checking.</p> <ul> <li>Linting: <code>make lint</code></li> <li>Formatting: <code>make format</code></li> <li>Type Checking: <code>make type-check</code></li> <li>Run all checks: <code>make all</code></li> </ul>"},{"location":"#documentation","title":"Documentation","text":"<p>The project documentation is built using MkDocs.</p> <ul> <li>Build Documentation: <code>make docs-build</code></li> <li>Serve Documentation Locally: <code>make docs-serve</code></li> </ul>"},{"location":"#license","title":"License","text":"<p>GPLv3</p>"},{"location":"#ai-assistance-development-workflow","title":"AI Assistance &amp; Development Workflow","text":"<p>This project is developed with the assistance of an AI coding agent using the Gemini CLI tool. The AI is also used to generate commit messages and parts of the documentation, including API and theoretical reference sections.</p> <p>Workflow: 1.  Context &amp; Theory (Human): The maintainer, Hiroshi Atsuta, establishes the project roadmap in <code>GEMINI.md</code> and writes the theoretical background implemented as documentation in docs/reference/. 2.  Scaffolding (AI): The AI assistant uses these documents and the constraints defined in <code>GEMINI.md</code> to implement code scaffolding and initial logic. 3.  Review &amp; Revision (Human): The maintainer reviews, tests, and revises the generated code to ensure quality and correctness. This cycle is repeated during the development.</p> <p>Responsibility: All responsibilities for the code hosted in this repository lie with the maintainer. The AI serves strictly as an implementation assistant; final architectural decisions and code quality are human-led.</p> <p>Feedback: If you identify problems, or find code that appears to be unoriginal or rights-protected, please notify the maintainer immediately by filing an issue.</p> <p>Contributor Policy: External contributors are welcome to use AI tools for assistance, provided they adhere to the same standard of review and responsibility. If you use AI to generate code for a Pull Request, please disclose it in the PR description and ensure you have thoroughly reviewed and tested the code.</p>"},{"location":"api/canvas/","title":"Canvas API","text":""},{"location":"api/canvas/#skelarm.canvas","title":"<code>skelarm.canvas</code>","text":"<p>Provides a PyQt6 widget for visualizing the robot arm.</p>"},{"location":"api/canvas/#skelarm.canvas.SkelarmCanvas","title":"<code>SkelarmCanvas</code>","text":"<p>               Bases: <code>QWidget</code></p> <p>A widget to draw the robot arm skeleton.</p> Source code in <code>src/skelarm/canvas.py</code> <pre><code>class SkelarmCanvas(QWidget):\n    \"\"\"A widget to draw the robot arm skeleton.\"\"\"\n\n    def __init__(self, skeleton: Skeleton, parent: QWidget | None = None) -&gt; None:\n        \"\"\"Initialize the canvas.\"\"\"\n        super().__init__(parent)\n        self.skeleton = skeleton\n        self.scale_factor = 100.0  # Pixels per meter\n        # Set background color to white\n        self.setAutoFillBackground(True)\n        p = self.palette()\n        p.setColor(self.backgroundRole(), QColor(\"white\"))\n        self.setPalette(p)\n\n    def paintEvent(self, a0) -&gt; None:  # noqa: ANN001, N802, ARG002\n        \"\"\"Paint the robot arm.\"\"\"\n        painter = QPainter(self)\n        painter.setRenderHint(QPainter.RenderHint.Antialiasing)\n\n        # Center of the widget\n        center_x = self.width() / 2\n        center_y = self.height() / 2\n\n        # Draw Base\n        painter.setBrush(QBrush(Qt.GlobalColor.black))\n        base_screen = self.world_to_screen(0, 0, center_x, center_y)\n        painter.drawEllipse(base_screen, 10, 10)\n\n        # Draw Links\n        pen_link = QPen(QColor(0, 100, 200))  # Blue-ish\n        pen_link.setWidth(6)\n        pen_link.setCapStyle(Qt.PenCapStyle.RoundCap)\n        painter.setPen(pen_link)\n\n        # Draw Joints\n        brush_joint = QBrush(QColor(200, 0, 0))  # Red\n\n        # Iterate through links\n        # Note: We assume compute_forward_kinematics has been called externally\n        # or we could call it here, but typically the state is updated elsewhere.\n\n        for link in self.skeleton.links:\n            p1 = self.world_to_screen(link.x, link.y, center_x, center_y)\n            p2 = self.world_to_screen(link.xe, link.ye, center_x, center_y)\n\n            # Draw link segment\n            painter.drawLine(p1, p2)\n\n            # Draw joint at the end of the link (tip or next joint)\n            painter.setPen(Qt.PenStyle.NoPen)\n            painter.setBrush(brush_joint)\n            painter.drawEllipse(p2, 6, 6)\n\n            # Reset pen for next link\n            painter.setPen(pen_link)\n\n    def world_to_screen(self, wx: float, wy: float, cx: float, cy: float) -&gt; QPointF:\n        \"\"\"Convert world coordinates (meters) to screen coordinates (pixels).\"\"\"\n        sx = cx + wx * self.scale_factor\n        # Invert Y because screen Y is down\n        sy = cy - wy * self.scale_factor\n        return QPointF(sx, sy)\n\n    def update_skeleton(self) -&gt; None:\n        \"\"\"Trigger a repaint.\"\"\"\n        self.update()\n</code></pre>"},{"location":"api/canvas/#skelarm.canvas.SkelarmCanvas.__init__","title":"<code>__init__(skeleton, parent=None)</code>","text":"<p>Initialize the canvas.</p> Source code in <code>src/skelarm/canvas.py</code> <pre><code>def __init__(self, skeleton: Skeleton, parent: QWidget | None = None) -&gt; None:\n    \"\"\"Initialize the canvas.\"\"\"\n    super().__init__(parent)\n    self.skeleton = skeleton\n    self.scale_factor = 100.0  # Pixels per meter\n    # Set background color to white\n    self.setAutoFillBackground(True)\n    p = self.palette()\n    p.setColor(self.backgroundRole(), QColor(\"white\"))\n    self.setPalette(p)\n</code></pre>"},{"location":"api/canvas/#skelarm.canvas.SkelarmCanvas.paintEvent","title":"<code>paintEvent(a0)</code>","text":"<p>Paint the robot arm.</p> Source code in <code>src/skelarm/canvas.py</code> <pre><code>def paintEvent(self, a0) -&gt; None:  # noqa: ANN001, N802, ARG002\n    \"\"\"Paint the robot arm.\"\"\"\n    painter = QPainter(self)\n    painter.setRenderHint(QPainter.RenderHint.Antialiasing)\n\n    # Center of the widget\n    center_x = self.width() / 2\n    center_y = self.height() / 2\n\n    # Draw Base\n    painter.setBrush(QBrush(Qt.GlobalColor.black))\n    base_screen = self.world_to_screen(0, 0, center_x, center_y)\n    painter.drawEllipse(base_screen, 10, 10)\n\n    # Draw Links\n    pen_link = QPen(QColor(0, 100, 200))  # Blue-ish\n    pen_link.setWidth(6)\n    pen_link.setCapStyle(Qt.PenCapStyle.RoundCap)\n    painter.setPen(pen_link)\n\n    # Draw Joints\n    brush_joint = QBrush(QColor(200, 0, 0))  # Red\n\n    # Iterate through links\n    # Note: We assume compute_forward_kinematics has been called externally\n    # or we could call it here, but typically the state is updated elsewhere.\n\n    for link in self.skeleton.links:\n        p1 = self.world_to_screen(link.x, link.y, center_x, center_y)\n        p2 = self.world_to_screen(link.xe, link.ye, center_x, center_y)\n\n        # Draw link segment\n        painter.drawLine(p1, p2)\n\n        # Draw joint at the end of the link (tip or next joint)\n        painter.setPen(Qt.PenStyle.NoPen)\n        painter.setBrush(brush_joint)\n        painter.drawEllipse(p2, 6, 6)\n\n        # Reset pen for next link\n        painter.setPen(pen_link)\n</code></pre>"},{"location":"api/canvas/#skelarm.canvas.SkelarmCanvas.update_skeleton","title":"<code>update_skeleton()</code>","text":"<p>Trigger a repaint.</p> Source code in <code>src/skelarm/canvas.py</code> <pre><code>def update_skeleton(self) -&gt; None:\n    \"\"\"Trigger a repaint.\"\"\"\n    self.update()\n</code></pre>"},{"location":"api/canvas/#skelarm.canvas.SkelarmCanvas.world_to_screen","title":"<code>world_to_screen(wx, wy, cx, cy)</code>","text":"<p>Convert world coordinates (meters) to screen coordinates (pixels).</p> Source code in <code>src/skelarm/canvas.py</code> <pre><code>def world_to_screen(self, wx: float, wy: float, cx: float, cy: float) -&gt; QPointF:\n    \"\"\"Convert world coordinates (meters) to screen coordinates (pixels).\"\"\"\n    sx = cx + wx * self.scale_factor\n    # Invert Y because screen Y is down\n    sy = cy - wy * self.scale_factor\n    return QPointF(sx, sy)\n</code></pre>"},{"location":"api/canvas/#skelarm.canvas.SkelarmViewer","title":"<code>SkelarmViewer</code>","text":"<p>               Bases: <code>QMainWindow</code></p> <p>Main window for the Skelarm visualizer.</p> Source code in <code>src/skelarm/canvas.py</code> <pre><code>class SkelarmViewer(QMainWindow):\n    \"\"\"Main window for the Skelarm visualizer.\"\"\"\n\n    def __init__(self, skeleton: Skeleton) -&gt; None:\n        \"\"\"Initialize the viewer.\"\"\"\n        super().__init__()\n        self.skeleton = skeleton\n\n        # Ensure kinematics are computed initially\n        compute_forward_kinematics(self.skeleton)\n\n        self.canvas = SkelarmCanvas(skeleton)\n\n        self.setWindowTitle(\"Skelarm Viewer\")\n        self.resize(1024, 768)\n\n        # Main layout container\n        central_widget = QWidget()\n        self.setCentralWidget(central_widget)\n        main_layout = QHBoxLayout(central_widget)\n\n        # Add canvas\n        main_layout.addWidget(self.canvas, stretch=3)\n\n        # Controls panel\n        controls_panel = QWidget()\n        controls_layout = QVBoxLayout(controls_panel)\n\n        controls_label = QLabel(\"&lt;b&gt;Joint Controls&lt;/b&gt;\")\n        controls_layout.addWidget(controls_label)\n\n        self.sliders: list[QSlider] = []\n        self.angle_labels: list[QLabel] = []\n\n        for i, link in enumerate(skeleton.links):\n            row_layout = QVBoxLayout()\n\n            header_layout = QHBoxLayout()\n            label = QLabel(f\"Joint {i + 1}\")\n            value_label = QLabel(\"0.0\u00b0\")\n            header_layout.addWidget(label)\n            header_layout.addStretch()\n            header_layout.addWidget(value_label)\n\n            slider = QSlider(Qt.Orientation.Horizontal)\n            # Map -180..180 degrees to slider values\n            # Using link limits if available would be better, but fixed for now\n            slider.setRange(-180, 180)\n            # Set initial value\n            initial_deg = int(math.degrees(link.q))\n            slider.setValue(initial_deg)\n            slider.valueChanged.connect(self.on_slider_change)\n\n            row_layout.addLayout(header_layout)\n            row_layout.addWidget(slider)\n\n            controls_layout.addLayout(row_layout)\n            controls_layout.addSpacing(10)\n\n            self.sliders.append(slider)\n            self.angle_labels.append(value_label)\n\n            # Initialize label text\n            value_label.setText(f\"{initial_deg}\u00b0\")\n\n        controls_layout.addStretch()\n        main_layout.addWidget(controls_panel, stretch=1)\n\n    def on_slider_change(self) -&gt; None:\n        \"\"\"Handle slider value changes.\"\"\"\n        new_q = []\n        for i, slider in enumerate(self.sliders):\n            angle_deg = slider.value()\n            self.angle_labels[i].setText(f\"{angle_deg}\u00b0\")\n            new_q.append(math.radians(angle_deg))\n\n        self.skeleton.q = np.array(new_q)\n        compute_forward_kinematics(self.skeleton)\n        self.canvas.update_skeleton()\n</code></pre>"},{"location":"api/canvas/#skelarm.canvas.SkelarmViewer.__init__","title":"<code>__init__(skeleton)</code>","text":"<p>Initialize the viewer.</p> Source code in <code>src/skelarm/canvas.py</code> <pre><code>def __init__(self, skeleton: Skeleton) -&gt; None:\n    \"\"\"Initialize the viewer.\"\"\"\n    super().__init__()\n    self.skeleton = skeleton\n\n    # Ensure kinematics are computed initially\n    compute_forward_kinematics(self.skeleton)\n\n    self.canvas = SkelarmCanvas(skeleton)\n\n    self.setWindowTitle(\"Skelarm Viewer\")\n    self.resize(1024, 768)\n\n    # Main layout container\n    central_widget = QWidget()\n    self.setCentralWidget(central_widget)\n    main_layout = QHBoxLayout(central_widget)\n\n    # Add canvas\n    main_layout.addWidget(self.canvas, stretch=3)\n\n    # Controls panel\n    controls_panel = QWidget()\n    controls_layout = QVBoxLayout(controls_panel)\n\n    controls_label = QLabel(\"&lt;b&gt;Joint Controls&lt;/b&gt;\")\n    controls_layout.addWidget(controls_label)\n\n    self.sliders: list[QSlider] = []\n    self.angle_labels: list[QLabel] = []\n\n    for i, link in enumerate(skeleton.links):\n        row_layout = QVBoxLayout()\n\n        header_layout = QHBoxLayout()\n        label = QLabel(f\"Joint {i + 1}\")\n        value_label = QLabel(\"0.0\u00b0\")\n        header_layout.addWidget(label)\n        header_layout.addStretch()\n        header_layout.addWidget(value_label)\n\n        slider = QSlider(Qt.Orientation.Horizontal)\n        # Map -180..180 degrees to slider values\n        # Using link limits if available would be better, but fixed for now\n        slider.setRange(-180, 180)\n        # Set initial value\n        initial_deg = int(math.degrees(link.q))\n        slider.setValue(initial_deg)\n        slider.valueChanged.connect(self.on_slider_change)\n\n        row_layout.addLayout(header_layout)\n        row_layout.addWidget(slider)\n\n        controls_layout.addLayout(row_layout)\n        controls_layout.addSpacing(10)\n\n        self.sliders.append(slider)\n        self.angle_labels.append(value_label)\n\n        # Initialize label text\n        value_label.setText(f\"{initial_deg}\u00b0\")\n\n    controls_layout.addStretch()\n    main_layout.addWidget(controls_panel, stretch=1)\n</code></pre>"},{"location":"api/canvas/#skelarm.canvas.SkelarmViewer.on_slider_change","title":"<code>on_slider_change()</code>","text":"<p>Handle slider value changes.</p> Source code in <code>src/skelarm/canvas.py</code> <pre><code>def on_slider_change(self) -&gt; None:\n    \"\"\"Handle slider value changes.\"\"\"\n    new_q = []\n    for i, slider in enumerate(self.sliders):\n        angle_deg = slider.value()\n        self.angle_labels[i].setText(f\"{angle_deg}\u00b0\")\n        new_q.append(math.radians(angle_deg))\n\n    self.skeleton.q = np.array(new_q)\n    compute_forward_kinematics(self.skeleton)\n    self.canvas.update_skeleton()\n</code></pre>"},{"location":"api/dynamics/","title":"Dynamics API","text":""},{"location":"api/dynamics/#skelarm.dynamics","title":"<code>skelarm.dynamics</code>","text":"<p>Provides functions for robot arm dynamics.</p>"},{"location":"api/dynamics/#skelarm.dynamics.compute_coriolis_gravity_vector","title":"<code>compute_coriolis_gravity_vector(skeleton, grav_vec=None)</code>","text":"<p>Compute the Coriolis and gravity vector h(q, dq).</p> <p>:param skeleton: The Skeleton object. :param grav_vec: The gravity vector. :return: The N-dimensional vector h.</p> Source code in <code>src/skelarm/dynamics.py</code> <pre><code>def compute_coriolis_gravity_vector(\n    skeleton: Skeleton,\n    grav_vec: NDArray[np.float64] | None = None,\n) -&gt; NDArray[np.float64]:\n    \"\"\"Compute the Coriolis and gravity vector h(q, dq).\n\n    :param skeleton: The Skeleton object.\n    :param grav_vec: The gravity vector.\n    :return: The N-dimensional vector h.\n    \"\"\"\n    if grav_vec is None:\n        grav_vec = np.array([0.0, 0.0], dtype=np.float64)\n\n    num_links = skeleton.num_links\n    original_q = skeleton.q\n    original_dq = skeleton.dq\n    original_ddq = skeleton.ddq\n\n    temp_skeleton = deepcopy(skeleton)\n    temp_skeleton.ddq = np.zeros(num_links)\n\n    compute_inverse_dynamics(temp_skeleton, grav_vec=grav_vec)\n    h_vector = temp_skeleton.tau\n\n    # Restore original state\n    skeleton.q = original_q\n    skeleton.dq = original_dq\n    skeleton.ddq = original_ddq\n\n    return h_vector\n</code></pre>"},{"location":"api/dynamics/#skelarm.dynamics.compute_forward_dynamics","title":"<code>compute_forward_dynamics(skeleton, tau, grav_vec=None)</code>","text":"<p>Compute joint accelerations ddq given torques.</p> <p>:param skeleton: The Skeleton object. :param tau: Joint torques. :param grav_vec: Gravity vector. :return: Joint accelerations ddq.</p> Source code in <code>src/skelarm/dynamics.py</code> <pre><code>def compute_forward_dynamics(\n    skeleton: Skeleton,\n    tau: NDArray[np.float64],\n    grav_vec: NDArray[np.float64] | None = None,\n) -&gt; NDArray[np.float64]:\n    \"\"\"Compute joint accelerations ddq given torques.\n\n    :param skeleton: The Skeleton object.\n    :param tau: Joint torques.\n    :param grav_vec: Gravity vector.\n    :return: Joint accelerations ddq.\n    \"\"\"\n    if grav_vec is None:\n        grav_vec = np.array([0.0, 0.0], dtype=np.float64)\n\n    temp_skeleton = deepcopy(skeleton)\n    mass_matrix = compute_mass_matrix(temp_skeleton)\n    coriolis_gravity_vector = compute_coriolis_gravity_vector(temp_skeleton, grav_vec=grav_vec)\n\n    rhs = tau - coriolis_gravity_vector\n    return np.linalg.solve(mass_matrix, rhs).astype(np.float64)\n</code></pre>"},{"location":"api/dynamics/#skelarm.dynamics.compute_inverse_dynamics","title":"<code>compute_inverse_dynamics(skeleton, grav_vec=None)</code>","text":"<p>Compute the inverse dynamics of the robot arm using the Recursive Newton-Euler algorithm.</p> <p>Updates the <code>tau</code> (joint torque) for each link in the skeleton.</p> <p>:param skeleton: The Skeleton object containing the robot arm's links and their states. :param grav_vec: A 2D NumPy array representing the gravity vector. Defaults to zero (planar motion).</p> Source code in <code>src/skelarm/dynamics.py</code> <pre><code>def compute_inverse_dynamics(\n    skeleton: Skeleton,\n    grav_vec: NDArray[np.float64] | None = None,\n) -&gt; None:\n    \"\"\"Compute the inverse dynamics of the robot arm using the Recursive Newton-Euler algorithm.\n\n    Updates the `tau` (joint torque) for each link in the skeleton.\n\n    :param skeleton: The Skeleton object containing the robot arm's links and their states.\n    :param grav_vec: A 2D NumPy array representing the gravity vector. Defaults to zero (planar motion).\n    \"\"\"\n    if grav_vec is None:\n        grav_vec = np.array([0.0, 0.0], dtype=np.float64)\n\n    # Initialize base angular and linear velocities/accelerations\n    # Assuming base is fixed at (0,0) with no rotation\n    prev_w = 0.0  # Angular velocity of the previous link frame\n    prev_dw = 0.0  # Angular acceleration of the previous link frame\n    prev_dv = -grav_vec  # Linear acceleration of the previous link origin (base)\n\n    # Forward Pass (Base to End-effector)\n    for i, link in enumerate(skeleton.links):\n        # Rotation matrix from previous frame to current frame (for 2D, purely angular)\n        if i == 0:\n            link_absolute_angle = link.q\n        else:\n            prev_link = skeleton.links[i - 1]\n            link_absolute_angle = prev_link.q_absolute + link.q\n\n        link.q_absolute = link_absolute_angle\n\n        # Angular velocity and acceleration (scalar sum for 2D)\n        link.w = prev_w + link.dq\n        link.dw = prev_dw + link.ddq\n\n        # Vector from previous joint to current joint (in base frame)\n        r_prev_to_curr = np.array(\n            [\n                link.prop.length * np.cos(link_absolute_angle),\n                link.prop.length * np.sin(link_absolute_angle),\n            ]\n        )\n\n        # Vector from current joint to COM (relative to link frame)\n        rc_curr = np.array([link.prop.rgx, link.prop.rgy])\n\n        # Rotate rc_curr to base frame\n        r_curr_to_base = np.array(\n            [\n                [np.cos(link_absolute_angle), -np.sin(link_absolute_angle)],\n                [np.sin(link_absolute_angle), np.cos(link_absolute_angle)],\n            ]\n        )\n        rc_curr_base_frame = r_curr_to_base @ rc_curr\n\n        # Linear acceleration of link origin (joint)\n        # 2D cross product terms:\n        # dw x r = [-dw * ry, dw * rx]\n        # w x (w x r) = [-w^2 * rx, -w^2 * ry]\n\n        cross_dw_r_prev = np.array([-prev_dw * r_prev_to_curr[1], prev_dw * r_prev_to_curr[0]])\n        term3 = np.array([-(prev_w**2) * r_prev_to_curr[0], -(prev_w**2) * r_prev_to_curr[1]])\n\n        link.dv = prev_dv + cross_dw_r_prev + term3\n\n        # Linear acceleration of center of mass (COM)\n        # dvc_i = dv_i + dw_i x rc_i + w_i x (w_i x rc_i)\n        cross_dw_rc = np.array([-link.dw * rc_curr_base_frame[1], link.dw * rc_curr_base_frame[0]])\n        term_com3 = np.array([-(link.w**2) * rc_curr_base_frame[0], -(link.w**2) * rc_curr_base_frame[1]])\n\n        link.dvc = link.dv + cross_dw_rc + term_com3\n\n        # Update for next iteration\n        prev_w = link.w\n        prev_dw = link.dw\n        prev_dv = link.dv\n\n    # Backward Pass (End-effector to Base)\n    for i in range(skeleton.num_links - 1, -1, -1):\n        link = skeleton.links[i]\n\n        # fi is the inertial force. Gravity is handled via initial prev_dv.\n        fi = link.prop.m * link.dvc\n        ni = link.prop.i * link.dw\n\n        # Forces/moments from the succeeding link\n        if i == skeleton.num_links - 1:\n            succ_f = np.array([link.fex, link.fey])\n            succ_n = 0.0\n        else:\n            succ_link = skeleton.links[i + 1]\n            succ_f = succ_link.f\n            succ_n = succ_link.n\n\n        # Vector from current joint to COM (in base frame)\n        # Reuse calculation logic\n        rc_curr = np.array([link.prop.rgx, link.prop.rgy])\n        r_curr_to_base = np.array(\n            [\n                [np.cos(link_absolute_angle), -np.sin(link_absolute_angle)],\n                [np.sin(link_absolute_angle), np.cos(link_absolute_angle)],\n            ]\n        )\n        rc_curr_base_frame = r_curr_to_base @ rc_curr\n\n        # Vector from COM to tip (succeeding joint) in base frame\n        l_curr_base_frame = np.array(\n            [\n                link.prop.length * np.cos(link_absolute_angle),\n                link.prop.length * np.sin(link_absolute_angle),\n            ]\n        )\n        lc_curr_base_frame = l_curr_base_frame - rc_curr_base_frame\n\n        # Force balance: f_i = F_i + f_{i+1}\n        link.f = fi + succ_f\n\n        # Moment balance: n_i = N_i + n_{i+1} + (r_{i, i+1} x f_{i+1}) + (r_{i, com} x F_i)\n        # 2D cross product: x*fy - y*fx\n        cross_lc_succ_f = lc_curr_base_frame[0] * succ_f[1] - lc_curr_base_frame[1] * succ_f[0]\n        cross_rc_fi = rc_curr_base_frame[0] * fi[1] - rc_curr_base_frame[1] * fi[0]\n\n        link.n = ni + succ_n + cross_lc_succ_f + cross_rc_fi\n\n        # Joint torque\n        # link.n is torque ON the link.\n        # link.tau is joint torque (reaction).\n        link.tau = link.n\n</code></pre>"},{"location":"api/dynamics/#skelarm.dynamics.compute_kinetic_energy","title":"<code>compute_kinetic_energy(skeleton)</code>","text":"<p>Compute the total kinetic energy of the robot arm.</p> <p>:param skeleton: The Skeleton object with link velocities (w, v, vc) computed. :return: The total kinetic energy.</p> Source code in <code>src/skelarm/dynamics.py</code> <pre><code>def compute_kinetic_energy(skeleton: Skeleton) -&gt; float:\n    \"\"\"Compute the total kinetic energy of the robot arm.\n\n    :param skeleton: The Skeleton object with link velocities (w, v, vc) computed.\n    :return: The total kinetic energy.\n    \"\"\"\n    total_ke = 0.0\n    for link in skeleton.links:\n        # Kinetic energy of a rigid body: 0.5 * m * vc^2 + 0.5 * I * w^2\n        # vc is a 2D vector, so vc^2 = vc_x^2 + vc_y^2\n        vc_squared = np.dot(link.vc, link.vc)\n        ke_translational = 0.5 * link.prop.m * vc_squared\n        ke_rotational = 0.5 * link.prop.i * (link.w**2)\n        total_ke += ke_translational + ke_rotational\n    return total_ke\n</code></pre>"},{"location":"api/dynamics/#skelarm.dynamics.compute_kinetic_energy_rate","title":"<code>compute_kinetic_energy_rate(skeleton, tau, grav_vec=None)</code>","text":"<p>Compute the rate of change of kinetic energy (dKE/dt).</p> <p>dKE/dt = dq^T * tau_applied. In the context of the dynamics equation Mddq + h = tau, dKE/dt should be dq^T * (Mddq + h). This must equal dq^T * tau_applied.</p> <p>:param skeleton: The Skeleton object with current q and dq. :param tau: The N-dimensional vector of joint torques. :param grav_vec: The gravity vector. :return: The rate of change of kinetic energy.</p> Source code in <code>src/skelarm/dynamics.py</code> <pre><code>def compute_kinetic_energy_rate(\n    skeleton: Skeleton,\n    tau: NDArray[np.float64],\n    grav_vec: NDArray[np.float64] | None = None,\n) -&gt; float:\n    \"\"\"Compute the rate of change of kinetic energy (dKE/dt).\n\n    dKE/dt = dq^T * tau_applied.\n    In the context of the dynamics equation M*ddq + h = tau,\n    dKE/dt should be dq^T * (M*ddq + h). This must equal dq^T * tau_applied.\n\n    :param skeleton: The Skeleton object with current q and dq.\n    :param tau: The N-dimensional vector of joint torques.\n    :param grav_vec: The gravity vector.\n    :return: The rate of change of kinetic energy.\n    \"\"\"\n    if grav_vec is None:\n        grav_vec = np.array([0.0, 0.0], dtype=np.float64)\n\n    # Need current ddq to check consistency\n    ddq = compute_forward_dynamics(skeleton, tau, grav_vec)\n\n    # Reconstruct tau from ddq, M, h\n    temp_skeleton = deepcopy(skeleton)\n    mass_matrix = compute_mass_matrix(temp_skeleton)\n    coriolis_gravity_vector = compute_coriolis_gravity_vector(temp_skeleton, grav_vec=grav_vec)\n\n    # The torque on the left side of the equation M*ddq + h = tau\n    tau_lhs = mass_matrix @ ddq + coriolis_gravity_vector\n\n    # dKE/dt = dq^T * tau\n    # We check dq^T * tau_lhs, which should be equal to dq^T * tau (input)\n    return float(np.dot(skeleton.dq, tau_lhs))\n</code></pre>"},{"location":"api/dynamics/#skelarm.dynamics.compute_mass_matrix","title":"<code>compute_mass_matrix(skeleton, _grav_vec=None)</code>","text":"<p>Compute the mass matrix M(q) for the robot arm.</p> <p>:param skeleton: The Skeleton object. :param _grav_vec: Ignored, should be zero for mass matrix. :return: The N x N mass matrix.</p> Source code in <code>src/skelarm/dynamics.py</code> <pre><code>def compute_mass_matrix(\n    skeleton: Skeleton,\n    _grav_vec: NDArray[np.float64] | None = None,  # Renamed to _grav_vec as it's ignored\n) -&gt; NDArray[np.float64]:\n    \"\"\"Compute the mass matrix M(q) for the robot arm.\n\n    :param skeleton: The Skeleton object.\n    :param _grav_vec: Ignored, should be zero for mass matrix.\n    :return: The N x N mass matrix.\n    \"\"\"\n    # Mass matrix calculation requires zero gravity\n    # We pass explicit zero vector to ensure no gravity influence\n    zero_grav = np.array([0.0, 0.0], dtype=np.float64)\n\n    num_links = skeleton.num_links\n    mass_matrix = np.zeros((num_links, num_links), dtype=np.float64)\n\n    original_q = skeleton.q\n    original_dq = skeleton.dq\n    original_ddq = skeleton.ddq\n\n    temp_skeleton = deepcopy(skeleton)\n    temp_skeleton.dq = np.zeros(num_links)\n\n    for j in range(num_links):\n        ddq_j_one = np.zeros(num_links)\n        ddq_j_one[j] = 1.0\n        temp_skeleton.ddq = ddq_j_one\n\n        compute_inverse_dynamics(temp_skeleton, grav_vec=zero_grav)\n        mass_matrix[:, j] = temp_skeleton.tau\n\n    skeleton.q = original_q\n    skeleton.dq = original_dq\n    skeleton.ddq = original_ddq\n\n    return mass_matrix\n</code></pre>"},{"location":"api/dynamics/#skelarm.dynamics.simulate_robot","title":"<code>simulate_robot(initial_skeleton, time_span, control_torques_func, grav_vec=None, dt=0.01, rtol=1e-06, atol=1e-08)</code>","text":"<p>Simulate robot dynamics.</p> <p>:param initial_skeleton: The initial Skeleton state (q, dq). :param time_span: A tuple (start_time, end_time) for the simulation. :param control_torques_func: A callable function <code>f(t, skeleton) -&gt; tau</code> that returns                              the N-dimensional control torques for the current time and skeleton state. :param grav_vec: The gravity vector. :param dt: Time step for the simulation, used for output points. :param rtol: Relative tolerance for the ODE solver. :param atol: Absolute tolerance for the ODE solver. :return: A tuple (times, q_trajectory, dq_trajectory) of NumPy arrays.</p> Source code in <code>src/skelarm/dynamics.py</code> <pre><code>def simulate_robot(\n    initial_skeleton: Skeleton,\n    time_span: tuple[float, float],\n    control_torques_func: Callable[[float, Skeleton], NDArray[np.float64]],\n    grav_vec: NDArray[np.float64] | None = None,\n    dt: float = 0.01,\n    rtol: float = 1e-6,\n    atol: float = 1e-8,\n) -&gt; tuple[NDArray[np.float64], NDArray[np.float64], NDArray[np.float64]]:\n    \"\"\"Simulate robot dynamics.\n\n    :param initial_skeleton: The initial Skeleton state (q, dq).\n    :param time_span: A tuple (start_time, end_time) for the simulation.\n    :param control_torques_func: A callable function `f(t, skeleton) -&gt; tau` that returns\n                                 the N-dimensional control torques for the current time and skeleton state.\n    :param grav_vec: The gravity vector.\n    :param dt: Time step for the simulation, used for output points.\n    :param rtol: Relative tolerance for the ODE solver.\n    :param atol: Absolute tolerance for the ODE solver.\n    :return: A tuple (times, q_trajectory, dq_trajectory) of NumPy arrays.\n    \"\"\"\n    if grav_vec is None:\n        grav_vec = np.array([0.0, 0.0], dtype=np.float64)\n\n    num_links = initial_skeleton.num_links\n\n    def ode_system(t: float, state: NDArray[np.float64]) -&gt; NDArray[np.float64]:\n        q = state[:num_links]\n        dq = state[num_links:]\n\n        current_skeleton = deepcopy(initial_skeleton)\n        current_skeleton.q = q\n        current_skeleton.dq = dq\n        # ddq is computed, not set from state\n\n        tau = control_torques_func(t, current_skeleton)\n        ddq = compute_forward_dynamics(current_skeleton, tau, grav_vec)\n\n        return np.concatenate((dq, ddq))\n\n    initial_state = np.concatenate((initial_skeleton.q, initial_skeleton.dq))\n    t_eval = np.arange(time_span[0], time_span[1] + dt, dt)\n\n    solution = solve_ivp(\n        ode_system,\n        time_span,\n        initial_state,\n        t_eval=t_eval,\n        method=\"RK45\",\n        rtol=rtol,\n        atol=atol,\n    )\n\n    if not solution.success:\n        msg = f\"ODE integration failed: {solution.message}\"\n        raise RuntimeError(msg)\n\n    q_trajectory = solution.y[:num_links, :].T\n    dq_trajectory = solution.y[num_links:, :].T\n\n    return solution.t, q_trajectory, dq_trajectory\n</code></pre>"},{"location":"api/kinematics/","title":"Kinematics API","text":""},{"location":"api/kinematics/#skelarm.kinematics","title":"<code>skelarm.kinematics</code>","text":"<p>Provides functions for robot arm kinematics.</p>"},{"location":"api/kinematics/#skelarm.kinematics.compute_forward_kinematics","title":"<code>compute_forward_kinematics(skeleton)</code>","text":"<p>Compute the forward kinematics (positions and velocities) for the given skeleton.</p> <p>Updates the (x, y) positions of each link's end-effector (tip) and joints, as well as the linear and angular velocities of joints and COM.</p> <p>The base of the robot arm is assumed to be at (0, 0) with zero velocity.</p> <p>:param skeleton: The Skeleton object containing the robot arm's links and joint angles.</p> Source code in <code>src/skelarm/kinematics.py</code> <pre><code>def compute_forward_kinematics(skeleton: Skeleton) -&gt; None:\n    \"\"\"Compute the forward kinematics (positions and velocities) for the given skeleton.\n\n    Updates the (x, y) positions of each link's end-effector (tip) and joints,\n    as well as the linear and angular velocities of joints and COM.\n\n    The base of the robot arm is assumed to be at (0, 0) with zero velocity.\n\n    :param skeleton: The Skeleton object containing the robot arm's links and joint angles.\n    \"\"\"\n    current_x = 0.0\n    current_y = 0.0\n    current_angle = 0.0  # Absolute angle of the current link\n\n    # Initialize base velocities\n    prev_w = 0.0  # Angular velocity of the previous link frame\n    prev_v = np.array([0.0, 0.0], dtype=np.float64)  # Linear velocity of the previous link origin (base)\n\n    for link in skeleton.links:\n        # Store the start of the link (joint position)\n        link.x = current_x\n        link.y = current_y\n\n        # Add the current joint angle to the absolute angle\n        current_angle += link.q\n        link.q_absolute = current_angle\n\n        # Calculate the end-effector position of the current link\n        delta_x = link.prop.length * np.cos(current_angle)\n        delta_y = link.prop.length * np.sin(current_angle)\n\n        current_x += delta_x\n        current_y += delta_y\n\n        # Store the end-effector position of the current link\n        link.xe = current_x\n        link.ye = current_y\n\n        # Compute angular velocity (scalar for 2D)\n        link.w = prev_w + link.dq\n\n        # Vector from previous joint to current joint (in base frame)\n        r_prev_to_curr = np.array(\n            [\n                link.prop.length * np.cos(current_angle),\n                link.prop.length * np.sin(current_angle),\n            ]\n        )\n\n        # Compute linear velocity of current joint\n        # v_i = v_{i-1} + w_{i-1} x r_i\n        # 2D cross product: w x r = [-w*ry, w*rx]\n        cross_w_r_prev = np.array([-prev_w * r_prev_to_curr[1], prev_w * r_prev_to_curr[0]])\n        link.v = prev_v + cross_w_r_prev\n\n        # Vector from current joint to COM (relative to link frame)\n        rc_curr = np.array([link.prop.rgx, link.prop.rgy])\n\n        # Rotate rc_curr to base frame\n        r_curr_to_base = np.array(\n            [\n                [np.cos(current_angle), -np.sin(current_angle)],\n                [np.sin(current_angle), np.cos(current_angle)],\n            ]\n        )\n        rc_curr_base_frame = r_curr_to_base @ rc_curr\n\n        # Compute linear velocity of COM\n        # vc_i = v_i + w_i x rc_i\n        cross_w_rc = np.array([-link.w * rc_curr_base_frame[1], link.w * rc_curr_base_frame[0]])\n        link.vc = link.v + cross_w_rc\n\n        # Update for next iteration\n        prev_w = link.w\n        prev_v = link.v\n</code></pre>"},{"location":"api/plotting/","title":"Plotting API","text":""},{"location":"api/plotting/#skelarm.plotting","title":"<code>skelarm.plotting</code>","text":"<p>Provides utility functions for plotting robot arm states and trajectories.</p>"},{"location":"api/plotting/#skelarm.plotting.draw_skeleton","title":"<code>draw_skeleton(ax, skeleton, color='blue', linewidth=2.0)</code>","text":"<p>Draw the robot arm skeleton on a given Matplotlib Axes object.</p> <p>:param ax: The Matplotlib Axes object to draw on. :param skeleton: The Skeleton object containing the robot arm's links. :param color: Color of the robot arm links. :param linewidth: Width of the lines representing the links.</p> Source code in <code>src/skelarm/plotting.py</code> <pre><code>def draw_skeleton(ax: matplotlib.axes.Axes, skeleton: Skeleton, color: str = \"blue\", linewidth: float = 2.0) -&gt; None:\n    \"\"\"\n    Draw the robot arm skeleton on a given Matplotlib Axes object.\n\n    :param ax: The Matplotlib Axes object to draw on.\n    :param skeleton: The Skeleton object containing the robot arm's links.\n    :param color: Color of the robot arm links.\n    :param linewidth: Width of the lines representing the links.\n    \"\"\"\n    if not skeleton.links:\n        return\n\n    # Extract joint and end-effector positions\n    joint_x = [link.x for link in skeleton.links]\n    joint_y = [link.y for link in skeleton.links]\n    tip_x = [link.xe for link in skeleton.links]\n    tip_y = [link.ye for link in skeleton.links]\n\n    # Combine all x and y coordinates for plotting\n    all_x_coords = [0.0, *joint_x]  # Start from base (0,0)\n    all_y_coords = [0.0, *joint_y]  # Start from base (0,0)\n\n    # For each link, draw a line from its start (joint) to its end (tip)\n    for i in range(skeleton.num_links):\n        x_coords = [skeleton.links[i].x, skeleton.links[i].xe]\n        y_coords = [skeleton.links[i].y, skeleton.links[i].ye]\n        ax.plot(x_coords, y_coords, color=color, linewidth=linewidth, marker=\"o\", markersize=5)\n\n    # Set appropriate limits\n    all_coords = [abs(c) for c in all_x_coords + all_y_coords + tip_x + tip_y]\n    max_range = max(all_coords) * 1.1 if all_coords else 1.0  # Ensure max_range is not 0 for empty list\n\n    ax.set_xlim(-max_range, max_range)\n    ax.set_ylim(-max_range, max_range)\n    ax.set_aspect(\"equal\", adjustable=\"box\")\n    ax.set_xlabel(\"X Position\")\n    ax.set_ylabel(\"Y Position\")\n    ax.set_title(\"Robot Arm Skeleton\")\n    ax.grid()  # FBT003: Use ax.grid() instead of ax.grid(True)\n</code></pre>"},{"location":"api/plotting/#skelarm.plotting.plot_trajectory","title":"<code>plot_trajectory(ax, trajectory_x, trajectory_y, color='red', linestyle='-', linewidth=1.0)</code>","text":"<p>Plot a 2D trajectory on a given Matplotlib Axes object.</p> <p>:param ax: The Matplotlib Axes object to draw on. :param trajectory_x: NumPy array of x-coordinates for the trajectory. :param trajectory_y: NumPy array of y-coordinates for the trajectory. :param color: Color of the trajectory line. :param linestyle: Style of the trajectory line (e.g., '-', '--', ':'). :param linewidth: Width of the trajectory line.</p> Source code in <code>src/skelarm/plotting.py</code> <pre><code>def plot_trajectory(\n    ax: matplotlib.axes.Axes,\n    trajectory_x: NDArray[np.float64],\n    trajectory_y: NDArray[np.float64],\n    color: str = \"red\",\n    linestyle: str = \"-\",\n    linewidth: float = 1.0,\n) -&gt; None:\n    \"\"\"\n    Plot a 2D trajectory on a given Matplotlib Axes object.\n\n    :param ax: The Matplotlib Axes object to draw on.\n    :param trajectory_x: NumPy array of x-coordinates for the trajectory.\n    :param trajectory_y: NumPy array of y-coordinates for the trajectory.\n    :param color: Color of the trajectory line.\n    :param linestyle: Style of the trajectory line (e.g., '-', '--', ':').\n    :param linewidth: Width of the trajectory line.\n    \"\"\"\n    ax.plot(trajectory_x, trajectory_y, color=color, linestyle=linestyle, linewidth=linewidth, label=\"Tip Trajectory\")\n    ax.legend()\n    ax.set_xlabel(\"X Position\")\n    ax.set_ylabel(\"Y Position\")\n    ax.set_title(\"Tip Trajectory\")\n    ax.grid()  # FBT003: Use ax.grid() instead of ax.grid(True)\n</code></pre>"},{"location":"api/skeleton/","title":"Skeleton API","text":""},{"location":"api/skeleton/#skelarm.skeleton","title":"<code>skelarm.skeleton</code>","text":"<p>Defines the Link and Skeleton classes for the skelarm robot arm simulator.</p>"},{"location":"api/skeleton/#skelarm.skeleton.Link","title":"<code>Link</code>","text":"<p>Represents a single link of the robot arm.</p> Source code in <code>src/skelarm/skeleton.py</code> <pre><code>class Link:\n    \"\"\"Represents a single link of the robot arm.\"\"\"\n\n    def __init__(self, properties: LinkProp | dict[str, Any]) -&gt; None:\n        \"\"\"\n        Initialize a Link object from LinkProp or a dictionary.\n\n        :param properties: Either a LinkProp object or a dictionary containing\n                           link properties ('length', 'm', 'i', 'rgx', 'rgy', 'qmin', 'qmax').\n        \"\"\"\n        if isinstance(properties, LinkProp):\n            self.prop = properties\n        elif isinstance(properties, dict):\n            # Ensure 'l' is handled if passed in dict, convert to 'length'\n            if \"l\" in properties:\n                properties[\"length\"] = properties.pop(\"l\")\n            self.prop = LinkProp(**properties)\n        else:\n            error_msg = \"Properties must be a LinkProp object or a dictionary.\"\n            raise TypeError(error_msg)\n\n        # State variables, initialized to zeros or defaults\n        self.q: float = 0.0  # Joint angle\n        self.dq: float = 0.0  # Joint angular velocity\n        self.ddq: float = 0.0  # Joint angular acceleration\n        self.q_absolute: float = 0.0  # Absolute angle of the link (used in RNE)\n\n        # End-effector position and velocity (local to link)\n        self.x: float = 0.0\n        self.y: float = 0.0\n        self.vx: float = 0.0\n        self.vy: float = 0.0\n        self.ax: float = 0.0\n        self.ay: float = 0.0\n\n        # Center of mass position and velocity (global)\n        self.xg: float = 0.0\n        self.yg: float = 0.0\n        self.agx: float = 0.0\n        self.agy: float = 0.0\n\n        # Joint forces/torques\n        self.jx: float = 0.0  # Force at joint x\n        self.jy: float = 0.0  # Force at joint y\n        self.hx: float = 0.0  # Moment at joint x\n        self.hy: float = 0.0  # Moment at joint y\n        self.fx: float = 0.0  # Force applied to link x\n        self.fy: float = 0.0  # Force applied to link y\n        self.tau: float = 0.0  # Torque at joint\n\n        # External forces/torques\n        self.fex: float = 0.0  # External force x\n        self.fey: float = 0.0  # External force y\n        self.rex: float = 0.0  # External force x application point\n        self.rey: float = 0.0  # External force y application point\n\n        # End-effector position (global)\n        self.xe: float = 0.0\n        self.ye: float = 0.0\n\n        # --- Attributes for Inverse Dynamics (RNE) ---\n        self.w: float = 0.0  # Angular velocity of link frame\n        self.dw: float = 0.0  # Angular acceleration of link frame\n\n        # Linear velocity/acceleration of link origin (joint)\n        self.v: NDArray[np.float64] = cast(\"NDArray[np.float64]\", np.zeros(2))\n        self.dv: NDArray[np.float64] = cast(\"NDArray[np.float64]\", np.zeros(2))\n\n        # Linear velocity/acceleration of center of mass\n        self.vc: NDArray[np.float64] = cast(\"NDArray[np.float64]\", np.zeros(2))\n        self.dvc: NDArray[np.float64] = cast(\"NDArray[np.float64]\", np.zeros(2))\n\n        # Forces and moments\n        self.f: NDArray[np.float64] = cast(\"NDArray[np.float64]\", np.zeros(2))  # Force from parent link\n        self.n: float = 0.0  # Moment exerted by parent link on current link\n</code></pre>"},{"location":"api/skeleton/#skelarm.skeleton.Link.__init__","title":"<code>__init__(properties)</code>","text":"<p>Initialize a Link object from LinkProp or a dictionary.</p> <p>:param properties: Either a LinkProp object or a dictionary containing                    link properties ('length', 'm', 'i', 'rgx', 'rgy', 'qmin', 'qmax').</p> Source code in <code>src/skelarm/skeleton.py</code> <pre><code>def __init__(self, properties: LinkProp | dict[str, Any]) -&gt; None:\n    \"\"\"\n    Initialize a Link object from LinkProp or a dictionary.\n\n    :param properties: Either a LinkProp object or a dictionary containing\n                       link properties ('length', 'm', 'i', 'rgx', 'rgy', 'qmin', 'qmax').\n    \"\"\"\n    if isinstance(properties, LinkProp):\n        self.prop = properties\n    elif isinstance(properties, dict):\n        # Ensure 'l' is handled if passed in dict, convert to 'length'\n        if \"l\" in properties:\n            properties[\"length\"] = properties.pop(\"l\")\n        self.prop = LinkProp(**properties)\n    else:\n        error_msg = \"Properties must be a LinkProp object or a dictionary.\"\n        raise TypeError(error_msg)\n\n    # State variables, initialized to zeros or defaults\n    self.q: float = 0.0  # Joint angle\n    self.dq: float = 0.0  # Joint angular velocity\n    self.ddq: float = 0.0  # Joint angular acceleration\n    self.q_absolute: float = 0.0  # Absolute angle of the link (used in RNE)\n\n    # End-effector position and velocity (local to link)\n    self.x: float = 0.0\n    self.y: float = 0.0\n    self.vx: float = 0.0\n    self.vy: float = 0.0\n    self.ax: float = 0.0\n    self.ay: float = 0.0\n\n    # Center of mass position and velocity (global)\n    self.xg: float = 0.0\n    self.yg: float = 0.0\n    self.agx: float = 0.0\n    self.agy: float = 0.0\n\n    # Joint forces/torques\n    self.jx: float = 0.0  # Force at joint x\n    self.jy: float = 0.0  # Force at joint y\n    self.hx: float = 0.0  # Moment at joint x\n    self.hy: float = 0.0  # Moment at joint y\n    self.fx: float = 0.0  # Force applied to link x\n    self.fy: float = 0.0  # Force applied to link y\n    self.tau: float = 0.0  # Torque at joint\n\n    # External forces/torques\n    self.fex: float = 0.0  # External force x\n    self.fey: float = 0.0  # External force y\n    self.rex: float = 0.0  # External force x application point\n    self.rey: float = 0.0  # External force y application point\n\n    # End-effector position (global)\n    self.xe: float = 0.0\n    self.ye: float = 0.0\n\n    # --- Attributes for Inverse Dynamics (RNE) ---\n    self.w: float = 0.0  # Angular velocity of link frame\n    self.dw: float = 0.0  # Angular acceleration of link frame\n\n    # Linear velocity/acceleration of link origin (joint)\n    self.v: NDArray[np.float64] = cast(\"NDArray[np.float64]\", np.zeros(2))\n    self.dv: NDArray[np.float64] = cast(\"NDArray[np.float64]\", np.zeros(2))\n\n    # Linear velocity/acceleration of center of mass\n    self.vc: NDArray[np.float64] = cast(\"NDArray[np.float64]\", np.zeros(2))\n    self.dvc: NDArray[np.float64] = cast(\"NDArray[np.float64]\", np.zeros(2))\n\n    # Forces and moments\n    self.f: NDArray[np.float64] = cast(\"NDArray[np.float64]\", np.zeros(2))  # Force from parent link\n    self.n: float = 0.0  # Moment exerted by parent link on current link\n</code></pre>"},{"location":"api/skeleton/#skelarm.skeleton.LinkProp","title":"<code>LinkProp</code>  <code>dataclass</code>","text":"<p>Properties of a single robot arm link.</p> Source code in <code>src/skelarm/skeleton.py</code> <pre><code>@dataclass\nclass LinkProp:\n    \"\"\"Properties of a single robot arm link.\"\"\"\n\n    length: float\n    m: float\n    i: float\n    rgx: float\n    rgy: float\n    qmin: float  # Radians\n    qmax: float  # Radians\n</code></pre>"},{"location":"api/skeleton/#skelarm.skeleton.Skeleton","title":"<code>Skeleton</code>","text":"<p>Represents the entire robot arm (skeleton).</p> Source code in <code>src/skelarm/skeleton.py</code> <pre><code>class Skeleton:\n    \"\"\"Represents the entire robot arm (skeleton).\"\"\"\n\n    def __init__(self, link_props: Sequence[LinkProp | dict[str, Any]]) -&gt; None:\n        \"\"\"\n        Initialize the Skeleton with a list of link properties.\n\n        :param link_props: A list of LinkProp objects or dictionaries, one for each link.\n        \"\"\"\n        self.links: list[Link] = [Link(prop) for prop in link_props]\n        self.num_links: int = len(self.links)\n\n    @classmethod\n    def from_toml(cls, file_path: str | Path) -&gt; Skeleton:\n        \"\"\"\n        Create a Skeleton from a TOML configuration file.\n\n        :param file_path: Path to the TOML file.\n        :return: A new Skeleton instance.\n        \"\"\"\n        path = Path(file_path)\n        with path.open(\"rb\") as f:\n            data = tomllib.load(f)\n\n        link_props = []\n        for link_data in data.get(\"link\", []):\n            # Extract properties from TOML data\n            length = link_data[\"length\"]\n            mass = link_data[\"mass\"]\n            inertia = link_data[\"inertia\"]\n\n            # Allow 'com' as [x, y] or 'rgx'/'rgy' keys\n            if \"com\" in link_data:\n                rgx, rgy = link_data[\"com\"]\n            else:\n                rgx = link_data.get(\"rgx\", 0.0)\n                rgy = link_data.get(\"rgy\", 0.0)\n\n            # Allow 'limits' as [min, max] or 'qmin'/'qmax' keys\n            if \"limits\" in link_data:\n                qmin_deg, qmax_deg = link_data[\"limits\"]\n            else:\n                qmin_deg = link_data.get(\"qmin\", -180.0)\n                qmax_deg = link_data.get(\"qmax\", 180.0)\n\n            # Convert limits from degrees (config) to radians (internal)\n            qmin = np.deg2rad(qmin_deg)\n            qmax = np.deg2rad(qmax_deg)\n\n            link_props.append(\n                LinkProp(\n                    length=length,\n                    m=mass,\n                    i=inertia,\n                    rgx=rgx,\n                    rgy=rgy,\n                    qmin=qmin,\n                    qmax=qmax,\n                )\n            )\n\n        return cls(link_props)\n\n    @property\n    def q(self) -&gt; NDArray[np.float64]:\n        \"\"\"Return current joint angles.\"\"\"\n        import numpy as np  # Import at runtime for actual usage\n\n        return np.array([link.q for link in self.links], dtype=np.float64)\n\n    @q.setter\n    def q(self, q_values: NDArray[np.float64]) -&gt; None:\n        \"\"\"Set joint angles.\"\"\"\n        if len(q_values) != self.num_links:\n            error_msg = f\"Expected {self.num_links} joint angles, but got {len(q_values)}\"\n            raise ValueError(error_msg)\n        for i, link in enumerate(self.links):\n            link.q = q_values[i]\n\n    @property\n    def dq(self) -&gt; NDArray[np.float64]:\n        \"\"\"Return current joint angular velocities.\"\"\"\n        import numpy as np  # Import at runtime for actual usage\n\n        return np.array([link.dq for link in self.links], dtype=np.float64)\n\n    @dq.setter\n    def dq(self, dq_values: NDArray[np.float64]) -&gt; None:\n        \"\"\"Set joint angular velocities.\"\"\"\n        if len(dq_values) != self.num_links:\n            error_msg = f\"Expected {self.num_links} joint angular velocities, but got {len(dq_values)}\"\n            raise ValueError(error_msg)\n        for i, link in enumerate(self.links):\n            link.dq = dq_values[i]\n\n    @property\n    def ddq(self) -&gt; NDArray[np.float64]:\n        \"\"\"Return current joint angular accelerations.\"\"\"\n        import numpy as np  # Import at runtime for actual usage\n\n        return np.array([link.ddq for link in self.links], dtype=np.float64)\n\n    @ddq.setter\n    def ddq(self, ddq_values: NDArray[np.float64]) -&gt; None:\n        \"\"\"Set joint angular accelerations.\"\"\"\n        if len(ddq_values) != self.num_links:\n            error_msg = f\"Expected {self.num_links} joint angular accelerations, but got {len(ddq_values)}\"\n            raise ValueError(error_msg)\n        for i, link in enumerate(self.links):\n            link.ddq = ddq_values[i]\n\n    @property\n    def tau(self) -&gt; NDArray[np.float64]:\n        \"\"\"Return current joint torques.\"\"\"\n        import numpy as np\n\n        return np.array([link.tau for link in self.links], dtype=np.float64)\n\n    @tau.setter\n    def tau(self, tau_values: NDArray[np.float64]) -&gt; None:\n        \"\"\"Set joint torques.\"\"\"\n        if len(tau_values) != self.num_links:\n            error_msg = f\"Expected {self.num_links} joint torques, but got {len(tau_values)}\"\n            raise ValueError(error_msg)\n        for i, link in enumerate(self.links):\n            link.tau = tau_values[i]\n</code></pre>"},{"location":"api/skeleton/#skelarm.skeleton.Skeleton.ddq","title":"<code>ddq</code>  <code>property</code> <code>writable</code>","text":"<p>Return current joint angular accelerations.</p>"},{"location":"api/skeleton/#skelarm.skeleton.Skeleton.dq","title":"<code>dq</code>  <code>property</code> <code>writable</code>","text":"<p>Return current joint angular velocities.</p>"},{"location":"api/skeleton/#skelarm.skeleton.Skeleton.q","title":"<code>q</code>  <code>property</code> <code>writable</code>","text":"<p>Return current joint angles.</p>"},{"location":"api/skeleton/#skelarm.skeleton.Skeleton.tau","title":"<code>tau</code>  <code>property</code> <code>writable</code>","text":"<p>Return current joint torques.</p>"},{"location":"api/skeleton/#skelarm.skeleton.Skeleton.__init__","title":"<code>__init__(link_props)</code>","text":"<p>Initialize the Skeleton with a list of link properties.</p> <p>:param link_props: A list of LinkProp objects or dictionaries, one for each link.</p> Source code in <code>src/skelarm/skeleton.py</code> <pre><code>def __init__(self, link_props: Sequence[LinkProp | dict[str, Any]]) -&gt; None:\n    \"\"\"\n    Initialize the Skeleton with a list of link properties.\n\n    :param link_props: A list of LinkProp objects or dictionaries, one for each link.\n    \"\"\"\n    self.links: list[Link] = [Link(prop) for prop in link_props]\n    self.num_links: int = len(self.links)\n</code></pre>"},{"location":"api/skeleton/#skelarm.skeleton.Skeleton.from_toml","title":"<code>from_toml(file_path)</code>  <code>classmethod</code>","text":"<p>Create a Skeleton from a TOML configuration file.</p> <p>:param file_path: Path to the TOML file. :return: A new Skeleton instance.</p> Source code in <code>src/skelarm/skeleton.py</code> <pre><code>@classmethod\ndef from_toml(cls, file_path: str | Path) -&gt; Skeleton:\n    \"\"\"\n    Create a Skeleton from a TOML configuration file.\n\n    :param file_path: Path to the TOML file.\n    :return: A new Skeleton instance.\n    \"\"\"\n    path = Path(file_path)\n    with path.open(\"rb\") as f:\n        data = tomllib.load(f)\n\n    link_props = []\n    for link_data in data.get(\"link\", []):\n        # Extract properties from TOML data\n        length = link_data[\"length\"]\n        mass = link_data[\"mass\"]\n        inertia = link_data[\"inertia\"]\n\n        # Allow 'com' as [x, y] or 'rgx'/'rgy' keys\n        if \"com\" in link_data:\n            rgx, rgy = link_data[\"com\"]\n        else:\n            rgx = link_data.get(\"rgx\", 0.0)\n            rgy = link_data.get(\"rgy\", 0.0)\n\n        # Allow 'limits' as [min, max] or 'qmin'/'qmax' keys\n        if \"limits\" in link_data:\n            qmin_deg, qmax_deg = link_data[\"limits\"]\n        else:\n            qmin_deg = link_data.get(\"qmin\", -180.0)\n            qmax_deg = link_data.get(\"qmax\", 180.0)\n\n        # Convert limits from degrees (config) to radians (internal)\n        qmin = np.deg2rad(qmin_deg)\n        qmax = np.deg2rad(qmax_deg)\n\n        link_props.append(\n            LinkProp(\n                length=length,\n                m=mass,\n                i=inertia,\n                rgx=rgx,\n                rgy=rgy,\n                qmin=qmin,\n                qmax=qmax,\n            )\n        )\n\n    return cls(link_props)\n</code></pre>"},{"location":"reference/","title":"Reference Documentation","text":"<p>This section contains theoretical reference documentation for the <code>skelarm</code> robot kinematics and dynamics library. The content is derived from the project's foundational lessons.</p>"},{"location":"reference/#contents","title":"Contents","text":"<ol> <li>Differential Kinematics<ul> <li>Recursive position, velocity, and acceleration.</li> <li>Jacobian matrix formulation.</li> </ul> </li> <li>Inverse Dynamics<ul> <li>Newton-Euler equations.</li> <li>Force and torque balance recursive calculation.</li> </ul> </li> <li>Forward Dynamics<ul> <li>Lagrangian formulation.</li> <li>System Inertia Matrix (\\(H\\)) and Bias Force Vector (\\(b\\)).</li> <li>Equation of Motion: \\(H\\ddot{q} + b = \\tau\\).</li> </ul> </li> <li>Numerical Methods<ul> <li>Linear Equation Solver (Gaussian Elimination).</li> <li>ODE Solver (Euler, Runge-Kutta).</li> </ul> </li> </ol>"},{"location":"reference/01_differential_kinematics/","title":"Differential Kinematics","text":"<p>This document details the differential kinematics for a planar serial chain mechanism (e.g., a robot arm), as implemented in the <code>skelarm</code> project. It covers the relationship between joint velocities/accelerations and endpoint velocities/accelerations, as well as the computation of the Jacobian matrix.</p>"},{"location":"reference/01_differential_kinematics/#1-overview","title":"1. Overview","text":"<p>Forward kinematics maps a set of joint angles to the endpoint position. Differential kinematics extends this to describe the relationship between the rate of change of joint angles (joint velocities) and the endpoint velocity.</p> <p>Consider a planar \\(n\\)-link arm. - Let \\(q_i\\) be the joint angle of the \\(i\\)-th joint relative to the previous link. - Let \\(\\theta_i\\) be the absolute angle of the \\(i\\)-th link. - Let \\((x_i, y_i)\\) be the position of the \\(i\\)-th joint (or endpoint of the \\(i\\)-th link). - Let \\(l_i\\) be the length of the \\(i\\)-th link.</p>"},{"location":"reference/01_differential_kinematics/#2-recursive-velocity-and-acceleration","title":"2. Recursive Velocity and Acceleration","text":""},{"location":"reference/01_differential_kinematics/#velocity","title":"Velocity","text":"<p>The velocity of each link and joint can be computed recursively from the base (link 0) to the endpoint (link \\(n\\)).</p> <p>Base conditions (fixed base): $$ \\begin{aligned} \\dot{\\theta}_0 &amp;= 0 \\ \\dot{x}_0 &amp;= 0 \\ \\dot{y}_0 &amp;= 0 \\end{aligned} $$</p> <p>Recursive step (for \\(i = 1, \\dots, n\\)): $$ \\begin{aligned} \\dot{\\theta}i &amp;= \\dot{\\theta}{i-1} + \\dot{q}i \\ \\dot{x}_i &amp;= \\dot{x}{i-1} - \\dot{\\theta}i l_i \\sin \\theta_i \\ \\dot{y}_i &amp;= \\dot{y}{i-1} + \\dot{\\theta}_i l_i \\cos \\theta_i \\end{aligned} $$</p>"},{"location":"reference/01_differential_kinematics/#acceleration","title":"Acceleration","text":"<p>Similarly, acceleration can be computed recursively.</p> <p>Base conditions: $$ \\begin{aligned} \\ddot{\\theta}_0 &amp;= 0 \\ \\ddot{x}_0 &amp;= 0 \\ \\ddot{y}_0 &amp;= 0 \\end{aligned} $$</p> <p>Recursive step (for \\(i = 1, \\dots, n\\)): $$ \\begin{aligned} \\ddot{\\theta}i &amp;= \\ddot{\\theta}{i-1} + \\ddot{q}i \\ \\ddot{x}_i &amp;= \\ddot{x}{i-1} - \\dot{\\theta}i^2 l_i \\cos \\theta_i - \\ddot{\\theta}_i l_i \\sin \\theta_i \\ \\ddot{y}_i &amp;= \\ddot{y}{i-1} - \\dot{\\theta}_i^2 l_i \\sin \\theta_i + \\ddot{\\theta}_i l_i \\cos \\theta_i \\end{aligned} $$</p>"},{"location":"reference/01_differential_kinematics/#3-jacobian-matrix","title":"3. Jacobian Matrix","text":"<p>The relationship between the endpoint velocity \\((\\dot{x}, \\dot{y})\\) and the joint velocities \\(\\dot{q} = [\\dot{q}_1, \\dots, \\dot{q}_n]^T\\) is linear and defined by the Jacobian matrix \\(J\\):</p> \\[ \\begin{bmatrix} \\dot{x} \\\\ \\dot{y} \\end{bmatrix} = J \\dot{q} = \\begin{bmatrix} j_{x1} &amp; \\cdots &amp; j_{xn} \\\\ j_{y1} &amp; \\cdots &amp; j_{yn} \\end{bmatrix} \\begin{bmatrix} \\dot{q}_1 \\\\ \\vdots \\\\ \\dot{q}_n \\end{bmatrix} \\] <p>Or effectively: $$ \\dot{x} = \\sum_{i=1}^n j_{xi} \\dot{q}i, \\quad \\dot{y} = \\sum{i=1}^n j_{yi} \\dot{q}_i $$</p>"},{"location":"reference/01_differential_kinematics/#computing-jacobian-elements","title":"Computing Jacobian Elements","text":"<p>The elements of the Jacobian matrix can be computed recursively backward from the endpoint to the base.</p> <p>Base conditions (virtual link \\(n+1\\)): $\\(j_{x(n+1)} = 0, \\quad j_{y(n+1)} = 0\\)$</p> <p>Recursive step (for \\(i = n, \\dots, 1\\)): $$ \\begin{aligned} j_{xi} &amp;= j_{x(i+1)} - l_i \\sin \\theta_i \\ j_{yi} &amp;= j_{y(i+1)} + l_i \\cos \\theta_i \\end{aligned} $$</p> <p>Alternatively, geometrically: $$ \\begin{aligned} j_{xi} &amp;= -(y_n - y_{i-1}) \\ j_{yi} &amp;= x_n - x_{i-1} \\end{aligned} $$ where \\((x_n, y_n)\\) is the endpoint position and \\((x_{i-1}, y_{i-1})\\) is the position of the \\((i-1)\\)-th joint (the origin of link \\(i\\)).</p>"},{"location":"reference/01_differential_kinematics/#4-centripetal-and-coriolis-forces","title":"4. Centripetal and Coriolis Forces","text":"<p>The acceleration relationship can be expressed as:</p> \\[ \\begin{aligned} \\ddot{x} &amp;= \\sum_{i=1}^n (j_{xi} \\ddot{q}_i + h_{xi} \\dot{q}_i) \\\\ \\ddot{y} &amp;= \\sum_{i=1}^n (j_{yi} \\ddot{q}_i + h_{yi} \\dot{q}_i) \\end{aligned} \\] <p>where \\(h_{xi}\\) and \\(h_{yi}\\) represent the basis for centripetal and Coriolis accelerations.</p> <p>Recursive computation (backward): $$ \\begin{aligned} h_{xi} &amp;= -(\\dot{y}n - \\dot{y}{i-1}) = -\\sum_{j=i}^n j_{yj} \\dot{q}j \\ h{yi} &amp;= \\dot{x}n - \\dot{x}{i-1} = \\sum_{j=i}^n j_{xj} \\dot{q}_j \\end{aligned} $$</p>"},{"location":"reference/01_differential_kinematics/#5-implementation-notes","title":"5. Implementation Notes","text":"<p>The <code>skeleton_t</code> and <code>link_t</code> structures in the codebase should maintain these values. - Forward pass (<code>skeleton_update_state</code>): Compute \\(\\theta_i, x_i, y_i\\) and their derivatives. - Backward pass (<code>skeleton_update_jacobi</code>): Compute Jacobian columns \\(j_{xi}, j_{yi}\\) and Coriolis bases \\(h_{xi}, h_{yi}\\).</p> <p>This allows for efficient computation of endpoint velocity and acceleration given the joint state.</p>"},{"location":"reference/02_inverse_dynamics/","title":"Inverse Dynamics","text":"<p>This document details the inverse dynamics formulation for the planar serial chain mechanism. Inverse dynamics answers the question: \"What forces/torques are required to produce a desired acceleration?\"</p>"},{"location":"reference/02_inverse_dynamics/#1-mass-properties","title":"1. Mass Properties","text":"<p>For each link \\(i\\), we define: - \\(m_i\\): Mass of the link. - \\((x_{Gi}, y_{Gi})\\): Position of the center of mass (CoM). - \\(I_i\\): Moment of inertia about the CoM.</p> <p>The CoM is defined relative to the joint frame by offsets \\(r_{ix}\\) (longitudinal) and \\(r_{iy}\\) (perpendicular). $$ \\begin{aligned} x_{Gi} &amp;= x_{i-1} + r_{ix} \\cos \\theta_i - r_{iy} \\sin \\theta_i \\ y_{Gi} &amp;= y_{i-1} + r_{ix} \\sin \\theta_i + r_{iy} \\cos \\theta_i \\end{aligned} $$</p> <p>The velocity and acceleration of the CoM (\\(\\\\dot{x}_{Gi}, \\\\dot{y}_{Gi}, \\\\ddot{x}_{Gi}, \\\\ddot{y}_{Gi}\\)) are obtained by differentiating these positions with respect to time.</p>"},{"location":"reference/02_inverse_dynamics/#2-equation-of-motion-for-a-single-link","title":"2. Equation of Motion for a Single Link","text":"<p>The dynamics of the \\(i\\)-th link are governed by:</p> \\[ \\begin{aligned} m_i \\\\ddot{x}_{Gi} &amp;= f_{Gix} \\\\ m_i \\\\ddot{y}_{Gi} &amp;= f_{Giy} \\\\ I_i \\\\ddot{\\\\theta}_i &amp;= n_{Gi} \\end{aligned} \\] <p>where: - \\((f_{Gix}, f_{Giy})\\) is the net force acting on the CoM. - \\(n_{Gi}\\) is the net torque acting on the link.</p>"},{"location":"reference/02_inverse_dynamics/#3-force-analysis","title":"3. Force Analysis","text":"<p>Three types of forces act on each segment: 1.  Actuation Force/Torque (\\(\\\\tau_i\\)): Generated by motors at the joints. 2.  Constraint Force (\\(f_{ix}, f_{iy}\\)): Forces at the joints maintaining connection between links. 3.  External Force (\\(f_{Eix}, f_{Eiy}\\)): Forces from the environment acting at a point \\((x_{Ei}, y_{Ei})\\).</p> <p>The net force and torque on link \\(i\\) are the sum of these interactions. Note that link \\(i\\) is connected to link \\(i-1\\) (at joint \\(i\\)) and link \\(i+1\\) (at joint \\(i+1\\)).</p> <p>Force Balance: $$ \\begin{aligned} f_{Gix} &amp;= f_{ix} - f_{(i+1)x} + f_{Eix} \\ f_{Giy} &amp;= f_{iy} - f_{(i+1)y} + f_{Eiy} \\end{aligned} $$</p> <p>Torque Balance: $$ \\begin{aligned} n_{Gi} &amp;= \\tau_i - \\tau_{i+1} \\        &amp;\\quad + (x_{i-1} - x_{Gi})f_{iy} - (y_{i-1} - y_{Gi})f_{ix} \\quad \\text{(Force from joint } i) \\        &amp;\\quad - (x_i - x_{Gi})f_{(i+1)y} + (y_i - y_{Gi})f_{(i+1)x} \\quad \\text{(Force from joint } i+1) \\        &amp;\\quad + (x_{Ei} - x_{Gi})f_{Eiy} - (y_{Ei} - y_{Gi})f_{Eix} \\quad \\text{(External force)} \\end{aligned} $$</p>"},{"location":"reference/02_inverse_dynamics/#4-recursive-computation-inverse-dynamics","title":"4. Recursive Computation (Inverse Dynamics)","text":"<p>To find the joint torques \\(\\\\tau_i\\), we compute recursively backward from the tip (\\(n\\)) to the base (\\(1\\)).</p> <p>Base conditions (Tip): $$ f_{(n+1)x} = 0, \\quad f_{(n+1)y} = 0, \\quad \\tau_{n+1} = 0 $$</p> <p>Recursive step (for \\(i = n, \\dots, 1\\)): First, solve for the constraint forces at joint \\(i\\) required to support the link's motion and the forces from link \\(i+1\\):</p> \\[ \\begin{aligned} f_{ix} &amp;= m_i \\\\ddot{x}_{Gi} + f_{(i+1)x} - f_{Eix} \\\\ f_{iy} &amp;= m_i \\\\ddot{y}_{Gi} + f_{(i+1)y} - f_{Eiy} \\end{aligned} \\] <p>Then, solve for the actuation torque \\(\\\\tau_i\\):</p> \\[ \\begin{aligned} \\\\tau_i &amp;= I_i \\\\ddot{\\\\theta}_i + \\\\tau_{i+1} \\\\        &amp;\\\\quad - (x_{i-1} - x_{Gi})f_{iy} + (y_{i-1} - y_{Gi})f_{ix} \\\\        &amp;\\\\quad + (x_i - x_{Gi})f_{(i+1)y} - (y_i - y_{Gi})f_{(i+1)x} \\\\        &amp;\\\\quad - (x_{Ei} - x_{Gi})f_{Eiy} + (y_{Ei} - y_{Gi})f_{Eix} \\end{aligned} \\] <p>Or equivalently, using the joint positions directly in the torque balance:</p> <p>$$ \\begin{aligned} \\tau_i &amp;= n_{Gi} + \\tau_{i+1} \\        &amp;\\quad - (x_i - x_{i-1}) f_{(i+1)y} + (y_i - y_{i-1}) f_{(i+1)x} \\        &amp;\\quad + (x_{Ei} - x_{i-1}) f_{Eiy} - (y_{Ei} - y_{i-1}) f_{Eix} \\        &amp;\\quad - (x_{Gi} - x_{i-1}) f_{Giy} + (y_{Gi} - y_{i-1}) f_{Gix} \\end{aligned} $$ (Note: The exact formulation in code may vary slightly in term grouping, but follows Newton-Euler logic.)</p>"},{"location":"reference/02_inverse_dynamics/#5-implementation","title":"5. Implementation","text":"<p>The function <code>skeleton_update_force</code> implements this backward recursion. 1.  Ensure kinematics (acceleration of CoM) are updated first. 2.  Iterate from \\(i=n\\) down to \\(1\\). 3.  Compute net forces/torques required (\\(f_{Gi}, n_{Gi}\\)) from Newton's laws. 4.  Compute joint constraint forces \\((f_{ix}, f_{iy})\\). 5.  Compute joint torque \\(\\\\tau_i\\).</p>"},{"location":"reference/03_forward_dynamics/","title":"Forward Dynamics","text":"<p>This document details the forward dynamics formulation. Forward dynamics finds the acceleration \\(\\ddot{q}\\) produced by a given set of actuation forces \\(\\tau\\).</p>"},{"location":"reference/03_forward_dynamics/#1-equation-of-motion","title":"1. Equation of Motion","text":"<p>The equation of motion for the system is derived using Lagrange's method and is expressed in the standard form:</p> \\[ H(q) \\ddot{q} + b(q, \\dot{q}) = \\tau + J_E^T(q) f_E \\] <p>where: - \\(H(q) \\in \\mathbb{R}^{n \\times n}\\) is the System Inertia Matrix (symmetric, positive definite). - \\(b(q, \\dot{q}) \\in \\mathbb{R}^{n}\\) is the System Bias Force Vector (containing Coriolis, centrifugal, and gravity terms). - \\(\\tau \\in \\mathbb{R}^{n}\\) is the vector of joint actuation torques. - \\(f_E\\) is the external force vector acting at a specific point. - \\(J_E\\) is the Jacobian of the external force application point.</p>"},{"location":"reference/03_forward_dynamics/#2-derivation-and-components","title":"2. Derivation and Components","text":""},{"location":"reference/03_forward_dynamics/#kinetic-energy","title":"Kinetic Energy","text":"<p>The kinetic energy \\(K\\) of the system is: $$ K = \\frac{1}{2} \\sum_{k=1}^n \\left{ m_k (\\dot{x}{Gk}^2 + \\dot{y}{Gk}^2) + I_k \\dot{\\theta}_k^2 \\right} $$</p>"},{"location":"reference/03_forward_dynamics/#system-inertia-matrix-h","title":"System Inertia Matrix (\\(H\\))","text":"<p>The elements \\(h_{ij}\\) of the matrix \\(H\\) are computed as:</p> \\[ h_{ij} = \\sum_{k=\\max(i,j)}^n \\left[ m_k \\{ (x_{Gk} - x_{i-1})(x_{Gk} - x_{j-1}) + (y_{Gk} - y_{i-1})(y_{Gk} - y_{j-1}) \\} + I_k \\right] \\] <p>This matrix represents the inertial coupling between joints.</p>"},{"location":"reference/03_forward_dynamics/#bias-force-vector-b","title":"Bias Force Vector (\\(b\\))","text":"<p>The elements \\(b_i\\) of the vector \\(b\\) represent the forces arising from velocity-dependent terms (Coriolis and Centrifugal):</p> \\[ b_i = \\sum_{k=i}^n m_k \\sum_{j=1}^n \\left\\{ (y_{Gk} - y_{i-1}) h_{xkj} - (x_{Gk} - x_{i-1}) h_{ykj} \\right\\} \\dot{\\theta}_j^2 \\] <p>where \\(h_{xkj}\\) and \\(h_{ykj}\\) are geometric coefficients defined in the kinematic analysis.</p>"},{"location":"reference/03_forward_dynamics/#3-solving-for-acceleration","title":"3. Solving for Acceleration","text":"<p>To simulate motion, we need to solve for \\(\\ddot{q}\\):</p> \\[ \\ddot{q} = H^{-1} (\\tau - b + J_E^T f_E) \\] <p>Since inverting \\(H\\) directly is computationally expensive and unnecessary, we typically solve the linear system:</p> <p>$$ H \\ddot{q} = \\text{RHS} $$ where \\(\\text{RHS} = \\tau - b + J_E^T f_E\\). This is done using a linear equation solver (e.g., Gauss elimination).</p>"},{"location":"reference/03_forward_dynamics/#4-consistency-check","title":"4. Consistency Check","text":"<p>A crucial validation step is to ensure that the Forward Dynamics and Inverse Dynamics implementations are consistent. - Inverse Dynamics: Given \\(q, \\dot{q}, \\ddot{q}\\), calculate \\(\\tau\\). - Forward Dynamics: Given \\(q, \\dot{q}, \\tau\\), calculate \\(\\ddot{q}\\).</p> <p>If we compute \\(\\tau\\) from a known \\(\\ddot{q}\\) using Inverse Dynamics, and then feed that \\(\\tau\\) into Forward Dynamics, we should recover the original \\(\\ddot{q}\\) (within numerical limits).</p> <p>The function <code>skeleton_fd</code> should implement the construction of \\(H\\) and \\(b\\) and solve for \\(\\ddot{q}\\).</p>"},{"location":"reference/04_numerical_methods/","title":"Numerical Methods","text":"<p>This document describes the numerical methods used to solve the mathematical models of the robot arm.</p>"},{"location":"reference/04_numerical_methods/#1-linear-equation-solver","title":"1. Linear Equation Solver","text":"<p>To solve the forward dynamics equation \\(H \\ddot{q} = \\text{RHS}\\), we solve a linear system of the form \\(Ax = b\\). Since \\(H\\) is symmetric and positive definite, robust methods like Cholesky decomposition could be used, but for general purposes, Gaussian Elimination is implemented.</p>"},{"location":"reference/04_numerical_methods/#gaussian-elimination","title":"Gaussian Elimination","text":"<p>The process involves transforming the augmented matrix \\([A | b]\\) into an upper triangular form (forward elimination) and then performing back substitution to find \\(x\\).</p> <p>Algorithm: 1.  Forward Elimination:     For each column \\(k\\) from 1 to \\(n-1\\):     - For each row \\(i\\) from \\(k+1\\) to \\(n\\):         - Compute factor \\(f = A_{ik} / A_{kk}\\).         - Subtract row \\(k\\) multiplied by \\(f\\) from row \\(i\\).         - \\(A_{ij} \\leftarrow A_{ij} - f \\cdot A_{kj}\\) for \\(j=k \\dots n\\).         - \\(b_i \\leftarrow b_i - f \\cdot b_k\\).</p> <ol> <li>Back Substitution:     For row \\(i\\) from \\(n\\) down to 1:<ul> <li>\\(x_i = (b_i - \\sum_{j=i+1}^n A_{ij} x_j) / A_{ii}\\).</li> </ul> </li> </ol> <p>Note: Pivoting (swapping rows to maximize the pivot element \\(|A_{kk}|\\)) is often necessary for numerical stability, though simple implementations might skip it if \\(A\\) is known to be well-behaved.</p>"},{"location":"reference/04_numerical_methods/#2-differential-equation-solver-integration","title":"2. Differential Equation Solver (Integration)","text":"<p>To simulate the motion over time, we integrate the joint acceleration \\(\\ddot{q}\\) to get velocity \\(\\dot{q}\\) and position \\(q\\). The state of the system is \\(X = [q^T, \\dot{q}^T]^T\\). The system dynamics can be written as \\(\\dot{X} = f(t, X)\\).</p>"},{"location":"reference/04_numerical_methods/#eulers-method","title":"Euler's Method","text":"<p>The simplest numerical integration method. It approximates the next state based on the current slope.</p> <p>$$ \\begin{aligned} \\dot{q}{k+1} &amp;= \\dot{q}_k + \\ddot{q}_k \\Delta t \\ q{k+1} &amp;= q_k + \\dot{q}_k \\Delta t \\end{aligned} $$ where \\(\\Delta t\\) is the time step. Error: \\(O(\\Delta t)\\) (Global error). It is often unstable or inaccurate for stiff systems or large steps.</p>"},{"location":"reference/04_numerical_methods/#runge-kutta-method-rk4","title":"Runge-Kutta Method (RK4)","text":"<p>The classical 4th-order Runge-Kutta method provides much higher accuracy by sampling the slope at four points within the time step.</p> <p>Let \\(y_k\\) be the state variable (e.g., \\(q\\) or \\(\\dot{q}\\)). $$ y_{k+1} = y_k + \\frac{\\Delta t}{6} (k_1 + 2k_2 + 2k_3 + k_4) $$</p> <p>where: - \\(k_1 = f(t_k, y_k)\\) - \\(k_2 = f(t_k + \\frac{\\Delta t}{2}, y_k + \\frac{\\Delta t}{2} k_1)\\) - \\(k_3 = f(t_k + \\frac{\\Delta t}{2}, y_k + \\frac{\\Delta t}{2} k_2)\\) - \\(k_4 = f(t_k + \\Delta t, y_k + \\Delta t k_3)\\)</p> <p>For our second-order system \\(\\ddot{q} = g(q, \\dot{q}, \\tau)\\), we apply this to the state vector \\(X = [q, \\dot{q}]\\).</p> <p>Error: \\(O(\\Delta t^4)\\). This is the standard method for simulating smooth mechanical systems.</p>"}]}